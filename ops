#!/usr/bin/env bash

# ops - Dynamic entrypoint for calling shell executables
# This script manages wrapper scripts for executables organized into subfolders

set -euo pipefail

# Version
__version__="0.3.2"

# Configuration
OPSC_WORKSPACE_DIR="${OPSC_WORKSPACE_DIR:-${HOME}/ops-command}"
OPSC_BIN_DIR="${OPSC_WORKSPACE_DIR}/bin"
OPSC_COMMAND_INDEX="${OPSC_BIN_DIR}/commands.yaml"
OPSC_SHELL_INIT_FILES=("${HOME}/.bashrc" "${HOME}/.zshrc")
# Default exclude directories for scanning (can be overridden via environment variable)
if [ -z "${OPSC_EXCLUDE_DIRS+set}" ]; then
    OPSC_EXCLUDE_DIRS=("*/node_modules/*" "*/.git/*" "*/venv/*" "*/lib/*" "*/dist/*")
fi

# Colors for output (optional, can be removed if not needed)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo "${timestamp} INFO: $*" >&2
}

log_error() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo -e "${RED}${timestamp} ERROR: $*${NC}" >&2
}

log_warn() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo -e "${YELLOW}${timestamp} WARN: $*${NC}" >&2
}

# Check if yq is available
check_yq() {
    if ! command -v yq &> /dev/null; then
        log_error "yq is required but not installed. Please install yq first."
        exit 2
    fi
}

# Determine namespace from scan directory
determine_namespace() {
    local scan_dir="$1"
    local namespace=""
    local quiet="${2:-false}"  # Optional quiet mode parameter
    
    # Check for .ops-command.yaml file
    local config_file="${scan_dir}/.ops-command.yaml"
    if [ -f "$config_file" ]; then
        # Suppress check_yq output - it will exit if yq is not found
        if ! command -v yq &> /dev/null; then
            log_error "yq is required but not installed. Please install yq first." >&2
            exit 2
        fi
        namespace=$(yq eval '.namespace // ""' "$config_file" 2>/dev/null || echo "")
        if [ -n "$namespace" ]; then
            if [ "$quiet" != "true" ]; then
                log_info "Found namespace in .ops-command.yaml: ${namespace}" >&2
            fi
            # Only output the namespace value to stdout
            echo "$namespace"
            return 0
        fi
    fi
    
    # Check if scan_dir is a git repository
    if git -C "$scan_dir" rev-parse --git-dir > /dev/null 2>&1; then
        local git_root
        git_root=$(git -C "$scan_dir" rev-parse --show-toplevel 2>/dev/null || echo "")
        if [ -n "$git_root" ]; then
            namespace=$(basename "$git_root")
            if [ "$quiet" != "true" ]; then
                log_info "Found git repository, using namespace: ${namespace}" >&2
            fi
            # Only output the namespace value to stdout
            echo "$namespace"
            return 0
        fi
    fi
    
    # No namespace found
    echo ""
    return 0
}

# Get the shell type (bash or zsh)
get_shell_type() {
    # First check if we're actually running in zsh
    if [ -n "${ZSH_VERSION:-}" ]; then
        echo "zsh"
        return 0
    fi
    
    # Check the $SHELL environment variable (user's default shell)
    if [ -n "${SHELL:-}" ]; then
        case "$SHELL" in
            *zsh*)
                echo "zsh"
                return 0
                ;;
            *bash*)
                echo "bash"
                return 0
                ;;
        esac
    fi
    
    # Check parent process if available
    local parent_shell=$(ps -p ${PPID:-$$} -o comm= 2>/dev/null || echo "")
    if [[ "$parent_shell" == *zsh* ]]; then
        echo "zsh"
        return 0
    elif [[ "$parent_shell" == *bash* ]]; then
        echo "bash"
        return 0
    fi
    
    # Default to bash if we can't determine
    echo "bash"
}

# Check if a file has a shebang
has_shebang() {
    local file="$1"
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    # Read first line
    local first_line=$(head -n 1 "$file" 2>/dev/null || echo "")
    
    # Check if it starts with #!
    case "$first_line" in
        \#!*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Check if a file is executable
is_executable() {
    local file="$1"
    [ -x "$file" ] || return 1
}

# Check if a file should be skipped
should_skip_file() {
    local file="$1"
    
    # Skip if not executable
    if ! is_executable "$file"; then
        return 0
    fi
    
    # Skip if it's a binary (not a text file with shebang)
    if ! has_shebang "$file"; then
        # Check if it's likely a binary by checking file type
        local file_type=$(file -b "$file" 2>/dev/null || echo "")
        if echo "$file_type" | grep -qE "(binary|executable|Mach-O|ELF|PE32|shared library)"; then
            # Skip actual binaries
            return 0
        fi
        # Allow executable files without shebang (might be shell scripts)
        # They will be executed by the shell
    fi
    
    return 1
}

# Create wrapper script
create_wrapper_script() {
    local source_file="$1"
    local wrapper_name="$2"
    local wrapper_path="${OPSC_BIN_DIR}/${wrapper_name}.sh"
    local shell_type=$(get_shell_type)
    
    # Create bin directory if it doesn't exist
    mkdir -p "${OPSC_BIN_DIR}"
    
    # Determine shebang based on shell type
    local shebang="#!/usr/bin/env ${shell_type}"
    
    # Check if wrapper already exists
    if [ -f "$wrapper_path" ]; then
        # Update the source file path in the wrapper
        # Find the line with the source file invocation and replace it
        # The wrapper script has a specific format: the last executable line contains the script path
        local temp_wrapper=$(mktemp)
        local updated=false
        
        while IFS= read -r line || [ -n "$line" ]; do
            # Check if this line looks like a script execution (contains "$@" and quotes)
            # This matches lines like: "/path/to/script.sh" "$@"
            if [[ "$line" =~ \"\$@\" ]] && [[ "$line" =~ \".*\" ]]; then
                # Replace with new source file
                echo "\"${source_file}\" \"\$@\"" >> "$temp_wrapper"
                updated=true
            else
                echo "$line" >> "$temp_wrapper"
            fi
        done < "$wrapper_path"
        
        if [ "$updated" = true ]; then
            mv "$temp_wrapper" "$wrapper_path"
            chmod +x "$wrapper_path"
        else
            rm -f "$temp_wrapper"
        fi
    else
        # Create new wrapper script
        cat > "$wrapper_path" <<EOF
${shebang}

script_dir=\${0%/*}
script_name=\${0##*/}
script_base_name=\${script_name%%.*}
script_dir_name=\${script_dir##*/}
command_name="\${script_base_name}"

"${source_file}" "\$@"
EOF
        chmod +x "$wrapper_path"
    fi
}

# Add initialization block to shell init files
add_init_block() {
    local init_block="# >>> ops-command initialize >>>
# !! Contents within this block are managed by 'ops' !!
OPSC_WORKSPACE_DIR=\${OPSC_WORKSPACE_DIR-\${HOME}/ops-command}
export PATH=\"\${OPSC_WORKSPACE_DIR}/bin:\$PATH\"
# <<< ops-command <<<"

    for init_file in "${OPSC_SHELL_INIT_FILES[@]}"; do
        if [ ! -f "$init_file" ]; then
            # Create the file if it doesn't exist
            touch "$init_file"
        fi
        
        # Check if block already exists
        if ! grep -q "# >>> ops-command initialize >>>" "$init_file" 2>/dev/null; then
            # Append the block
            echo "" >> "$init_file"
            echo "$init_block" >> "$init_file"
            log_info "Added initialization block to ${init_file}"
        else
            log_info "Initialization block already exists in ${init_file}"
        fi
    done
}

# Update aliases block in shell init files
update_aliases_block() {
    local alias_entries=("$@")
    
    for init_file in "${OPSC_SHELL_INIT_FILES[@]}"; do
        if [ ! -f "$init_file" ]; then
            touch "$init_file"
        fi
        
        # Remove existing aliases block if it exists
        if grep -q "# >>> ops-command aliases >>>" "$init_file" 2>/dev/null; then
            # Extract everything before and after the aliases block
            local temp_file=$(mktemp)
            local in_block=false
            
            while IFS= read -r line; do
                if [[ "$line" == "# >>> ops-command aliases >>>" ]]; then
                    in_block=true
                    continue
                fi
                if [[ "$line" == "# <<< ops-command aliases <<<" ]]; then
                    in_block=false
                    continue
                fi
                if [ "$in_block" = false ]; then
                    echo "$line" >> "$temp_file"
                fi
            done < "$init_file"
            
            mv "$temp_file" "$init_file"
        fi
        
        # Add new aliases block
        {
            echo ""
            echo "# >>> ops-command aliases >>>"
            echo "# !! Contents within this block are managed by 'ops' !!"
            for alias_entry in "${alias_entries[@]}"; do
                echo "$alias_entry"
            done
            echo "# <<< ops-command aliases <<<"
        } >> "$init_file"
        
        log_info "Updated aliases block in ${init_file}"
    done
}

# Check if a string is a git URL
is_git_url() {
    local url="$1"
    [[ "$url" =~ ^https://.*\.git$ ]] || [[ "$url" =~ ^git@.*:.*\.git$ ]]
}

# Clone git repository if URL is provided
clone_git_repo() {
    local git_url="$1"
    local owner=""
    local repo=""
    local repo_path=""
    
    # Parse git URL to extract owner and repo
    if [[ "$git_url" =~ ^https://github.com/([^/]+)/([^/]+)\.git$ ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
    elif [[ "$git_url" =~ ^git@github.com:([^/]+)/([^/]+)\.git$ ]]; then
        owner="${BASH_REMATCH[1]}"
        repo="${BASH_REMATCH[2]}"
    else
        log_error "Unsupported git URL format: ${git_url}"
        log_error "Supported formats: https://github.com/owner/repo.git or git@github.com:owner/repo.git"
        exit 1
    fi
    
    # Create owner directory if it doesn't exist
    local owner_dir="${OPSC_WORKSPACE_DIR}/git/${owner}"
    mkdir -p "$owner_dir"
    
    # Clone repository
    repo_path="${owner_dir}/${repo}"
    
    if [ -d "$repo_path" ]; then
        log_info "Repository already exists at ${repo_path}, skipping clone"
    else
        log_info "Cloning repository ${git_url} to ${repo_path}"
        if ! git clone --quiet "$git_url" "$repo_path" 2>/dev/null; then
            log_error "Failed to clone repository: ${git_url}"
            exit 1
        fi
        log_info "Repository cloned successfully"
    fi
    
    echo "$repo_path"
}

# Scan directory for executables and create wrappers
scan_and_create_wrappers() {
    local scan_target="$1"
    local scan_dir=""
    
    # Check if scan_target is a git URL
    if is_git_url "$scan_target"; then
        scan_dir=$(clone_git_repo "$scan_target")
    else
        scan_dir="$scan_target"
    fi
    
    if [ ! -d "$scan_dir" ]; then
        log_error "Scan directory does not exist: ${scan_dir}"
        exit 1
    fi
    
    log_info "Scanning directory: ${scan_dir}"
    
    # Determine namespace from the cloned/scan directory
    local OPSC_NAMESPACE
    OPSC_NAMESPACE=$(determine_namespace "$scan_dir")
    
    # Create bin directory
    mkdir -p "${OPSC_BIN_DIR}"
    
    # Initialize command index
    local temp_index=$(mktemp)
    echo "commands:" > "$temp_index"
    
    local alias_entries=()
    local file_count=0
    
    # Find all files, excluding node_modules and .git
    while IFS= read -r -d '' file; do
        # Skip if file should be excluded
        if should_skip_file "$file"; then
            continue
        fi
        
        # Get relative path from scan_dir
        local rel_path="${file#$scan_dir/}"
        local dir_path=$(dirname "$rel_path")
        local base_name=$(basename "$file")
        local name_without_ext="${base_name%.*}"
        
        # Build wrapper name components from directory path
        local path_components=()
        
        # Handle files in root of scan_dir
        if [ "$dir_path" = "." ]; then
            path_components=("root")
        else
            # Split directory path into components
            # Replace / with space, then read into array
            local normalized_path="${dir_path#./}"  # Remove leading ./
            normalized_path="${normalized_path%/}"     # Remove trailing /
            
            # Use a while loop to split on /
            local temp_path="$normalized_path"
            while [ -n "$temp_path" ]; do
                local component="${temp_path%%/*}"
                if [ -n "$component" ] && [ "$component" != "." ]; then
                    path_components+=("$component")
                fi
                # Remove the component we just processed
                if [ "$temp_path" = "$component" ]; then
                    break
                fi
                temp_path="${temp_path#*/}"
            done
        fi
        
        # Build wrapper name
        local wrapper_name=""
        
        # Add namespace if present
        if [ -n "$OPSC_NAMESPACE" ]; then
            wrapper_name="$OPSC_NAMESPACE"
        fi
        
        # Add path components
        for component in "${path_components[@]}"; do
            if [ -z "$wrapper_name" ]; then
                wrapper_name="$component"
            else
                wrapper_name="${wrapper_name}.${component}"
            fi
        done
        
        # Add base name
        if [ -z "$wrapper_name" ]; then
            wrapper_name="$name_without_ext"
        else
            wrapper_name="${wrapper_name}.${name_without_ext}"
        fi
        
        # Create wrapper script
        create_wrapper_script "$file" "$wrapper_name"
        
        # Add to command index
        echo "  - name: \"${wrapper_name}\"" >> "$temp_index"
        echo "    path: \"${file}\"" >> "$temp_index"
        
        # Add to aliases
        if [[ -n "${OPSC_ALIAS_PREFIX:-}" ]];then 
          alias_entries+=("alias ${OPSC_ALIAS_PREFIX}.${wrapper_name}=\"${OPSC_BIN_DIR}/${wrapper_name}.sh\"")
        else
          alias_entries+=("alias ${wrapper_name}=\"${OPSC_BIN_DIR}/${wrapper_name}.sh\"")
        fi

        
        file_count=$((file_count + 1))
        log_info "Created wrapper: ${wrapper_name} -> ${file}"
        
    done < <(
        # Build find command with configurable exclude directories
        local find_args=("$scan_dir" -type f)
        for exclude_pattern in "${OPSC_EXCLUDE_DIRS[@]}"; do
            find_args+=(-not -path "$exclude_pattern")
        done
        find_args+=(-print0)
        find "${find_args[@]}"
    )
    
    # Move temp index to final location
    mv "$temp_index" "$OPSC_COMMAND_INDEX"
    
    log_info "Scanned ${file_count} files and created wrappers"
    log_info "Command index created at: ${OPSC_COMMAND_INDEX}"
    
    # Update aliases
    if [ ${#alias_entries[@]} -gt 0 ]; then
        update_aliases_block "${alias_entries[@]}"
    fi
}

# Initialize ops-command
init_dot_commander() {
    log_info "Initializing ops-command..."
    
    # Create workspace directory
    mkdir -p "${OPSC_WORKSPACE_DIR}"
    mkdir -p "${OPSC_BIN_DIR}"
    
    # Add initialization block to shell init files
    add_init_block
    
    log_info "ops-command initialized"
    log_info "Run \`ops ---help\` for usage information"
}

# Get available commands (for completion)
get_available_commands() {
    if [ ! -f "$OPSC_COMMAND_INDEX" ]; then
        return 0
    fi
    
    check_yq >&2
    
    # Parse YAML and extract command names
    local commands
    commands=$(yq eval '.commands[].name' "$OPSC_COMMAND_INDEX" 2>/dev/null || echo "")
    
    # Filter out log messages and output commands
    while IFS= read -r cmd; do
        if [ -n "$cmd" ] && [[ ! "$cmd" =~ ^[0-9]{12}[[:space:]]+INFO: ]]; then
            echo "$cmd"
        fi
    done <<< "$commands"
}

# Generate bash completion script
generate_bash_completion() {
    cat <<'EOFBASH'
# bash completion for ops
_ops_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Main options
    opts="---init ---scan ---help ---version ---completion ---update"
    
    # If we're completing the first argument and it starts with ---, complete options
    if [[ ${cur} == ---* ]]; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
    
    # If previous word is ---scan, complete directories
    if [[ ${prev} == ---scan ]]; then
        COMPREPLY=( $(compgen -d -- ${cur}) )
        return 0
    fi
    
    # Otherwise, complete with available commands from command index
    local command_index="${HOME}/ops-command/bin/commands.yaml"
    local commands=""
    
    if [ -f "$command_index" ] && command -v yq &> /dev/null; then
        commands=$(yq eval '.commands[].name' "$command_index" 2>/dev/null | grep -v "^[0-9]\{12\}[[:space:]]\+INFO:" || echo "")
    fi
    
    if [ -n "$commands" ]; then
        COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
    fi
}

complete -F _ops_completion ops
EOFBASH
}

# Generate zsh completion script
generate_zsh_completion() {
    cat <<'EOF'
#compdef ops

_ops() {
    local context state line
    local -a commands flags
    
    flags=(
        '---init:Initialize the script'\''s internal config'
        '---scan:Scan target directory for executables'
        '---help:Show help message'
        '---version:Show version information'
        '---completion:Generate completion scripts'
        '---update:Check for updates and update ops and command repos'
    )
    
    # Get available commands from command index
    if [ -f "${HOME}/ops-command/bin/commands.yaml" ]; then
        if command -v yq &> /dev/null; then
            commands=($(yq eval '.commands[].name' "${HOME}/ops-command/bin/commands.yaml" 2>/dev/null | grep -v "^[0-9]\{12\}[[:space:]]\+INFO:" || echo ""))
        fi
    fi
    
    _arguments -C \
        "1: :->command" \
        "*::arg:->args"
    
    case $state in
        command)
            if [[ $words[2] == ---* ]]; then
                _describe 'flags' flags
            else
                _describe 'commands' commands
            fi
            ;;
        args)
            case $words[2] in
                ---scan)
                    _files -/
                    ;;
                *)
                    _files
                    ;;
            esac
            ;;
    esac
}

_ops "$@"
EOF
}

# Install completion scripts
install_completion() {
    local shell_type=$(get_shell_type)
    local completion_installed=false
    
    if [ "$shell_type" = "bash" ]; then
        # Try to find bash completion directory
        local bash_completion_dir=""
        
        # Check common locations
        if [ -d "${HOME}/.bash_completion.d" ]; then
            bash_completion_dir="${HOME}/.bash_completion.d"
        elif [ -d "/usr/local/etc/bash_completion.d" ]; then
            bash_completion_dir="/usr/local/etc/bash_completion.d"
        elif [ -d "/etc/bash_completion.d" ]; then
            bash_completion_dir="/etc/bash_completion.d"
        fi
        
        if [ -n "$bash_completion_dir" ]; then
            generate_bash_completion > "${bash_completion_dir}/ops"
            chmod +x "${bash_completion_dir}/ops"
            log_info "Bash completion installed to ${bash_completion_dir}/ops"
            completion_installed=true
            
            # Add source line to .bashrc if not present
            if ! grep -q "source.*bash_completion.d/ops" "${HOME}/.bashrc" 2>/dev/null; then
                echo "" >> "${HOME}/.bashrc"
                echo "# ops completion" >> "${HOME}/.bashrc"
                echo "[ -f ${bash_completion_dir}/ops ] && source ${bash_completion_dir}/ops" >> "${HOME}/.bashrc"
                log_info "Added completion source to ~/.bashrc"
            fi
        else
            log_warn "Could not find bash completion directory. Please install manually:"
            echo "  ops ---completion > /path/to/completion/dir/ops"
        fi
    elif [ "$shell_type" = "zsh" ]; then
        # Try to find zsh completion directory
        local zsh_completion_dir=""
        
        # Check common locations
        if [ -d "${HOME}/.zsh/completions" ]; then
            zsh_completion_dir="${HOME}/.zsh/completions"
        elif [ -d "${HOME}/.zsh/functions" ]; then
            zsh_completion_dir="${HOME}/.zsh/functions"
        else
            # Create directory if it doesn't exist
            zsh_completion_dir="${HOME}/.zsh/completions"
            mkdir -p "$zsh_completion_dir"
        fi
        
        if [ -n "$zsh_completion_dir" ]; then
            generate_zsh_completion > "${zsh_completion_dir}/_ops"
            chmod +x "${zsh_completion_dir}/_ops"
            log_info "Zsh completion installed to ${zsh_completion_dir}/_ops"
            completion_installed=true
            
            # Add to fpath in .zshrc if not present
            if ! grep -q "fpath.*zsh/completions" "${HOME}/.zshrc" 2>/dev/null; then
                echo "" >> "${HOME}/.zshrc"
                echo "# ops-command completion" >> "${HOME}/.zshrc"
                echo "fpath=(${zsh_completion_dir} \$fpath)" >> "${HOME}/.zshrc"
                echo "autoload -U compinit && compinit" >> "${HOME}/.zshrc"
                log_info "Added completion to fpath in ~/.zshrc"
            fi
        fi
    fi
    
    if [ "$completion_installed" = true ]; then
        log_info "Completion installed successfully. Reload your shell or run:"
        if [ "$shell_type" = "bash" ]; then
            echo "  source ~/.bashrc"
        else
            echo "  source ~/.zshrc"
        fi
    fi
}

# Show version
show_version() {
    echo "ops version $__version__"
    exit 0
}

# Show help message
show_help() {
    echo "Usage:"
    echo "  ops ---init: Initialize the script's internal config"
    echo "  ops ---scan <target_dir>: Initialize and scan the target directory for executables"
    echo "  ops ---help: Show this help message"
    echo "  ops ---version: Show version information"
    echo "  ops ---completion: Generate and install shell completion scripts"
    echo "  ops ---update: Check for updates and update ops and command repos"
    echo "  ops <sub_command>: Execute a sub-command"
    echo ""
    
    if [ ! -f "$OPSC_COMMAND_INDEX" ]; then
        echo "No command index found. Run 'ops ---scan <dir>' to create one."
        return 0
    fi
    
    check_yq
    
    echo "Available Sub Commands:"
    
    # Use the get_available_commands function
    local commands
    commands=$(get_available_commands)
    
    if [ -z "$commands" ]; then
        echo "  (no commands found)"
        return 0
    fi
    
    while IFS= read -r cmd; do
        if [ -n "$cmd" ]; then
            echo "  - $cmd"
        fi
    done <<< "$commands"
}

# Check for updates to ops
check_ops_updates() {
    local current_version="$__version__"
    local ops_path=$(which ops 2>/dev/null || echo "")
    
    if [ -z "$ops_path" ]; then
        log_warn "Could not determine ops installation path"
        return 1
    fi
    
    # Check if ops was installed via installer (in /usr/local/bin or similar)
    if [[ "$ops_path" != *"ops-command"* ]] && [[ "$ops_path" =~ ^/(usr|opt|usr/local)/bin/ ]]; then
        # Try to get latest tag from GitHub
        local repo_url="https://github.com/berttejeda/bert.ops-command.git"
        local latest_tag=""
        
        if command -v git &> /dev/null; then
            latest_tag=$(git ls-remote --tags "$repo_url" 2>/dev/null | grep -v '\^{}' | sed 's/.*refs\/tags\///' | sort -V | tail -1 || echo "")
        fi
        
        if [ -n "$latest_tag" ] && [ "$latest_tag" != "v${current_version}" ] && [ "$latest_tag" != "${current_version}" ]; then
            echo "$latest_tag"
            return 0
        fi
    fi
    
    return 1
}

# Update ops to latest version
update_ops() {
    local latest_tag="$1"
    local ops_path=$(which ops)
    local temp_dir=$(mktemp -d)
    local repo_url="https://github.com/berttejeda/bert.ops-command.git"
    
    log_info "Updating ops to version ${latest_tag}"
    
    # Clone the repository
    if ! git clone --quiet --branch "$latest_tag" --depth 1 "$repo_url" "$temp_dir/repo" 2>/dev/null; then
        # Try without branch (just clone and checkout tag)
        git clone --quiet --depth 1 "$repo_url" "$temp_dir/repo" 2>/dev/null || return 1
        (cd "$temp_dir/repo" && git checkout --quiet "$latest_tag" 2>/dev/null || return 1)
    fi
    
    if [ ! -f "$temp_dir/repo/ops" ]; then
        log_error "ops script not found in repository"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Backup current version
    local backup_path="${ops_path}.backup.$(date +%Y%m%d%H%M%S)"
    cp "$ops_path" "$backup_path"
    log_info "Backed up current version to ${backup_path}"
    
    # Install new version
    if [ -w "$(dirname "$ops_path")" ]; then
        cp "$temp_dir/repo/ops" "$ops_path"
        chmod +x "$ops_path"
    else
        sudo cp "$temp_dir/repo/ops" "$ops_path"
        sudo chmod +x "$ops_path"
    fi
    
    rm -rf "$temp_dir"
    log_info "ops updated successfully to version ${latest_tag}"
    return 0
}

# Update command repositories
update_command_repos() {
    local git_dir="${OPSC_WORKSPACE_DIR}/git"
    
    if [ ! -d "$git_dir" ]; then
        log_info "No command repositories found at ${git_dir}"
        return 0
    fi
    
    local repos=()
    # Find all .git directories and extract their parent directories
    while IFS= read -r repo; do
        if [ -n "$repo" ] && [ -d "$repo/.git" ]; then
            repos+=("$repo")
        fi
    done < <(find "$git_dir" -type d -name ".git" 2>/dev/null | sed 's|/.git$||' | sort)
    
    if [ ${#repos[@]} -eq 0 ]; then
        log_info "No git repositories found in ${git_dir}"
        return 0
    fi
    
    echo ""
    echo "Found ${#repos[@]} command repository(ies):"
    for repo in "${repos[@]}"; do
        echo "  - $repo"
    done
    echo ""
    echo -e "${YELLOW}WARNING: Updating repositories will discard all local changes!${NC}"
    echo "This will run 'git clean -f . && git checkout .' before pulling updates."
    echo ""
    
    read -p "Would you like to update these repositories? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Skipping repository updates"
        return 0
    fi
    
    for repo in "${repos[@]}"; do
        log_info "Updating repository: $repo"
        (
            cd "$repo" || return 1
            # Discard all local changes and untracked files
            git clean -f . > /dev/null 2>&1
            git checkout . > /dev/null 2>&1
            # Now pull updates
            git pull --quiet 2>/dev/null || log_warn "Failed to update $repo"
        )
    done
    
    log_info "Repository updates complete"
}

# Handle update workflow
handle_update() {
    log_info "Checking for updates..."
    
    # Check for ops updates
    local latest_tag
    if latest_tag=$(check_ops_updates); then
        echo ""
        echo "A new version of ops is available: ${latest_tag}"
        echo "Current version: ${__version__}"
        read -p "Would you like to update ops? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            if update_ops "$latest_tag"; then
                log_info "ops updated successfully. Please restart your terminal."
            else
                log_error "Failed to update ops"
            fi
        fi
    else
        log_info "ops is up to date (version ${__version__})"
    fi
    
    # Check for command repository updates
    update_command_repos
}

# Execute subcommand
execute_subcommand() {
    local subcommand="$1"
    shift  # Remove subcommand from arguments
    
    local wrapper_script="${OPSC_BIN_DIR}/${subcommand}.sh"
    
    if [ ! -f "$wrapper_script" ]; then
        log_error "Subcommand not found: ${subcommand}"
        log_error "Run 'ops ---help' to see available commands"
        exit 1
    fi
    
    # Execute the wrapper script with remaining arguments
    exec "$wrapper_script" "$@"
}

# Main function
main() {
    local init_flag=false
    local scan_dir=""
    local help_flag=false
    local version_flag=false
    local completion_flag=false
    local update_flag=false
    local subcommand=""
    local original_args=("$@")
    local args_array=("$@")
    local i=0
    
    # First pass: parse flags and find subcommand
    while [ $i -lt ${#args_array[@]} ]; do
        local arg="${args_array[$i]}"
        case "$arg" in
            ---init)
                init_flag=true
                ;;
            ---scan)
                if [ $((i + 1)) -ge ${#args_array[@]} ]; then
                    log_error "---scan requires a directory argument"
                    exit 1
                fi
                scan_dir="${args_array[$((i + 1))]}"
                i=$((i + 1))  # Skip the directory argument
                ;;
            ---help)
                help_flag=true
                ;;
            ---version)
                version_flag=true
                ;;
            ---completion)
                completion_flag=true
                ;;
            ---update)
                update_flag=true
                ;;
            *)
                # This should be the subcommand (first non-flag argument)
                if [ -z "$subcommand" ] && [[ ! "$arg" =~ ^--- ]]; then
                    subcommand="$arg"
                fi
                ;;
        esac
        i=$((i + 1))
    done
    
    # Handle flags
    if [ "$help_flag" = true ]; then
        show_help
        exit 0
    fi
    
    if [ "$version_flag" = true ]; then
        show_version
        exit 0
    fi
    
    if [ "$update_flag" = true ]; then
        handle_update
        exit 0
    fi
    
    if [ "$completion_flag" = true ]; then
        install_completion
        exit 0
    fi
    
    # Handle ---scan: automatically initializes and scans
    if [ -n "$scan_dir" ]; then
        # Initialize (if not already done) and scan
        init_dot_commander
        scan_and_create_wrappers "$scan_dir"
        exit 0
    fi
    
    # Handle standalone ---init
    if [ "$init_flag" = true ]; then
        init_dot_commander
        exit 0
    fi
    
    # Handle subcommand execution
    if [ -n "$subcommand" ]; then
        # Reconstruct arguments without the subcommand and flags
        local remaining_args=()
        local found_subcommand=false
        local skip_next=false
        
        for ((j=0; j<${#original_args[@]}; j++)); do
            local arg="${original_args[$j]}"
            
            # Skip the next argument if we encountered ---scan
            if [ "$skip_next" = true ]; then
                skip_next=false
                continue
            fi
            
            # Skip flags
            case "$arg" in
                ---init|---help|---version|---completion|---update)
                    continue
                    ;;
                ---scan)
                    skip_next=true  # Skip the directory argument
                    continue
                    ;;
            esac
            
            # Skip the subcommand itself (only once)
            if [ "$found_subcommand" = false ] && [ "$arg" = "$subcommand" ]; then
                found_subcommand=true
                continue
            fi
            
            # Add all other arguments
            remaining_args+=("$arg")
        done
        
        # Safely pass remaining arguments (handle empty array case with set -u)
        # Check if array has elements before expanding to avoid unbound variable error
        if [ "${#remaining_args[*]}" -gt 0 ]; then
            execute_subcommand "$subcommand" "${remaining_args[@]}"
        else
            execute_subcommand "$subcommand"
        fi
        exit 0
    fi
    
    # No valid command provided
    log_error "No valid command provided. Run 'ops ---help' for usage information."
    exit 1
}

# Run main function
main "$@"


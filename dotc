#!/usr/bin/env bash

# dot-commander (dotc) - Dynamic entrypoint for calling shell executables
# This script manages wrapper scripts for executables organized into subfolders

set -euo pipefail

# Configuration
DC_WORKSPACE_DIR="${DC_WORKSPACE_DIR:-${HOME}/dot-commander}"
DC_BIN_DIR="${DC_WORKSPACE_DIR}/bin"
DC_COMMAND_INDEX="${DC_BIN_DIR}/commands.yaml"
DC_SHELL_INIT_FILES=("${HOME}/.bashrc" "${HOME}/.zshrc")

# Colors for output (optional, can be removed if not needed)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo "${timestamp} INFO: $*" >&2
}

log_error() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo -e "${RED}${timestamp} ERROR: $*${NC}" >&2
}

log_warn() {
    local timestamp=$(date +"%y%m%d%H%M%S")
    echo -e "${YELLOW}${timestamp} WARN: $*${NC}" >&2
}

# Check if yq is available
check_yq() {
    if ! command -v yq &> /dev/null; then
        log_error "yq is required but not installed. Please install yq first."
        exit 1
    fi
}

# Determine namespace from scan directory
determine_namespace() {
    local scan_dir="$1"
    local namespace=""
    local quiet="${2:-false}"  # Optional quiet mode parameter
    
    # Check for .dot-commander.yaml file
    local config_file="${scan_dir}/.dot-commander.yaml"
    if [ -f "$config_file" ]; then
        # Suppress check_yq output - it will exit if yq is not found
        if ! command -v yq &> /dev/null; then
            log_error "yq is required but not installed. Please install yq first." >&2
            echo ""
            return 1
        fi
        namespace=$(yq eval '.namespace // ""' "$config_file" 2>/dev/null || echo "")
        if [ -n "$namespace" ]; then
            if [ "$quiet" != "true" ]; then
                log_info "Found namespace in .dot-commander.yaml: ${namespace}" >&2
            fi
            # Only output the namespace value to stdout
            echo "$namespace"
            return 0
        fi
    fi
    
    # Check if scan_dir is a git repository
    if git -C "$scan_dir" rev-parse --git-dir > /dev/null 2>&1; then
        local git_root
        git_root=$(git -C "$scan_dir" rev-parse --show-toplevel 2>/dev/null || echo "")
        if [ -n "$git_root" ]; then
            namespace=$(basename "$git_root")
            if [ "$quiet" != "true" ]; then
                log_info "Found git repository, using namespace: ${namespace}" >&2
            fi
            # Only output the namespace value to stdout
            echo "$namespace"
            return 0
        fi
    fi
    
    # No namespace found
    echo ""
    return 0
}

# Get the shell type (bash or zsh)
get_shell_type() {
    if [ -n "${ZSH_VERSION:-}" ]; then
        echo "zsh"
    elif [ -n "${BASH_VERSION:-}" ]; then
        echo "bash"
    else
        echo "bash"  # default to bash
    fi
}

# Check if a file has a shebang
has_shebang() {
    local file="$1"
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    # Read first line
    local first_line=$(head -n 1 "$file" 2>/dev/null || echo "")
    
    # Check if it starts with #!
    case "$first_line" in
        \#!*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Check if a file is executable
is_executable() {
    local file="$1"
    [ -x "$file" ] || return 1
}

# Check if a file should be skipped
should_skip_file() {
    local file="$1"
    
    # Skip if not executable
    if ! is_executable "$file"; then
        return 0
    fi
    
    # Skip if it's a binary (not a text file with shebang)
    if ! has_shebang "$file"; then
        # Check if it's likely a binary by checking file type
        local file_type=$(file -b "$file" 2>/dev/null || echo "")
        if echo "$file_type" | grep -qE "(binary|executable|Mach-O|ELF|PE32|shared library)"; then
            # Skip actual binaries
            return 0
        fi
        # Allow executable files without shebang (might be shell scripts)
        # They will be executed by the shell
    fi
    
    return 1
}

# Create wrapper script
create_wrapper_script() {
    local source_file="$1"
    local wrapper_name="$2"
    local wrapper_path="${DC_BIN_DIR}/${wrapper_name}.sh"
    local shell_type=$(get_shell_type)
    
    # Create bin directory if it doesn't exist
    mkdir -p "${DC_BIN_DIR}"
    
    # Determine shebang based on shell type
    local shebang="#!/usr/bin/env ${shell_type}"
    
    # Check if wrapper already exists
    if [ -f "$wrapper_path" ]; then
        # Update the source file path in the wrapper
        # Find the line with the source file invocation and replace it
        # The wrapper script has a specific format: the last executable line contains the script path
        local temp_wrapper=$(mktemp)
        local updated=false
        
        while IFS= read -r line || [ -n "$line" ]; do
            # Check if this line looks like a script execution (contains "$@" and quotes)
            # This matches lines like: "/path/to/script.sh" "$@"
            if [[ "$line" =~ \"\$@\" ]] && [[ "$line" =~ \".*\" ]]; then
                # Replace with new source file
                echo "\"${source_file}\" \"\$@\"" >> "$temp_wrapper"
                updated=true
            else
                echo "$line" >> "$temp_wrapper"
            fi
        done < "$wrapper_path"
        
        if [ "$updated" = true ]; then
            mv "$temp_wrapper" "$wrapper_path"
            chmod +x "$wrapper_path"
        else
            rm -f "$temp_wrapper"
        fi
    else
        # Create new wrapper script
        cat > "$wrapper_path" <<EOF
${shebang}

script_dir=\${0%/*}
script_name=\${0##*/}
script_base_name=\${script_name%%.*}
script_dir_name=\${script_dir##*/}
command_name="\${script_base_name}"

"${source_file}" "\$@"
EOF
        chmod +x "$wrapper_path"
    fi
}

# Add initialization block to shell init files
add_init_block() {
    local init_block="# >>> dot-commander initialize >>>
# !! Contents within this block are managed by 'dot-commander (dotc)' !!
DC_WORKSPACE_DIR=\${DC_WORKSPACE_DIR-\${HOME}/dot-commander}
export PATH=\"\${DC_WORKSPACE_DIR}/bin:\$PATH\"
# <<< dot-commander <<<"

    for init_file in "${DC_SHELL_INIT_FILES[@]}"; do
        if [ ! -f "$init_file" ]; then
            # Create the file if it doesn't exist
            touch "$init_file"
        fi
        
        # Check if block already exists
        if ! grep -q "# >>> dot-commander initialize >>>" "$init_file" 2>/dev/null; then
            # Append the block
            echo "" >> "$init_file"
            echo "$init_block" >> "$init_file"
            log_info "Added initialization block to ${init_file}"
        else
            log_info "Initialization block already exists in ${init_file}"
        fi
    done
}

# Update aliases block in shell init files
update_aliases_block() {
    local alias_entries=("$@")
    
    for init_file in "${DC_SHELL_INIT_FILES[@]}"; do
        if [ ! -f "$init_file" ]; then
            touch "$init_file"
        fi
        
        # Remove existing aliases block if it exists
        if grep -q "# >>> dot-commander aliases >>>" "$init_file" 2>/dev/null; then
            # Extract everything before and after the aliases block
            local temp_file=$(mktemp)
            local in_block=false
            
            while IFS= read -r line; do
                if [[ "$line" == "# >>> dot-commander aliases >>>" ]]; then
                    in_block=true
                    continue
                fi
                if [[ "$line" == "# <<< dot-commander aliases <<<" ]]; then
                    in_block=false
                    continue
                fi
                if [ "$in_block" = false ]; then
                    echo "$line" >> "$temp_file"
                fi
            done < "$init_file"
            
            mv "$temp_file" "$init_file"
        fi
        
        # Add new aliases block
        {
            echo ""
            echo "# >>> dot-commander aliases >>>"
            echo "# !! Contents within this block are managed by 'dot-commander (dotc)' !!"
            for alias_entry in "${alias_entries[@]}"; do
                echo "$alias_entry"
            done
            echo "# <<< dot-commander aliases <<<"
        } >> "$init_file"
        
        log_info "Updated aliases block in ${init_file}"
    done
}

# Scan directory for executables and create wrappers
scan_and_create_wrappers() {
    local scan_dir="$1"
    
    if [ ! -d "$scan_dir" ]; then
        log_error "Scan directory does not exist: ${scan_dir}"
        exit 1
    fi
    
    log_info "Scanning directory: ${scan_dir}"
    
    # Determine namespace
    local DC_NAMESPACE
    DC_NAMESPACE=$(determine_namespace "$scan_dir")
    
    # Create bin directory
    mkdir -p "${DC_BIN_DIR}"
    
    # Initialize command index
    local temp_index=$(mktemp)
    echo "commands:" > "$temp_index"
    
    local alias_entries=()
    local file_count=0
    
    # Find all files, excluding node_modules and .git
    while IFS= read -r -d '' file; do
        # Skip if file should be excluded
        if should_skip_file "$file"; then
            continue
        fi
        
        # Get relative path from scan_dir
        local rel_path="${file#$scan_dir/}"
        local dir_path=$(dirname "$rel_path")
        local base_name=$(basename "$file")
        local name_without_ext="${base_name%.*}"
        
        # Build wrapper name components from directory path
        local path_components=()
        
        # Handle files in root of scan_dir
        if [ "$dir_path" = "." ]; then
            path_components=("root")
        else
            # Split directory path into components
            # Replace / with space, then read into array
            local normalized_path="${dir_path#./}"  # Remove leading ./
            normalized_path="${normalized_path%/}"     # Remove trailing /
            
            # Use a while loop to split on /
            local temp_path="$normalized_path"
            while [ -n "$temp_path" ]; do
                local component="${temp_path%%/*}"
                if [ -n "$component" ] && [ "$component" != "." ]; then
                    path_components+=("$component")
                fi
                # Remove the component we just processed
                if [ "$temp_path" = "$component" ]; then
                    break
                fi
                temp_path="${temp_path#*/}"
            done
        fi
        
        # Build wrapper name
        local wrapper_name=""
        
        # Add namespace if present
        if [ -n "$DC_NAMESPACE" ]; then
            wrapper_name="$DC_NAMESPACE"
        fi
        
        # Add path components
        for component in "${path_components[@]}"; do
            if [ -z "$wrapper_name" ]; then
                wrapper_name="$component"
            else
                wrapper_name="${wrapper_name}.${component}"
            fi
        done
        
        # Add base name
        if [ -z "$wrapper_name" ]; then
            wrapper_name="$name_without_ext"
        else
            wrapper_name="${wrapper_name}.${name_without_ext}"
        fi
        
        # Create wrapper script
        create_wrapper_script "$file" "$wrapper_name"
        
        # Add to command index
        echo "  - name: \"${wrapper_name}\"" >> "$temp_index"
        echo "    path: \"${file}\"" >> "$temp_index"
        
        # Add to aliases
        alias_entries+=("alias dotc.${wrapper_name}=\"${DC_BIN_DIR}/${wrapper_name}.sh\"")
        
        file_count=$((file_count + 1))
        log_info "Created wrapper: ${wrapper_name} -> ${file}"
        
    done < <(find "$scan_dir" -type f \
        -not -path "*/node_modules/*" \
        -not -path "*/.git/*" \
        -print0)
    
    # Move temp index to final location
    mv "$temp_index" "$DC_COMMAND_INDEX"
    
    log_info "Scanned ${file_count} files and created wrappers"
    log_info "Command index created at: ${DC_COMMAND_INDEX}"
    
    # Update aliases
    if [ ${#alias_entries[@]} -gt 0 ]; then
        update_aliases_block "${alias_entries[@]}"
    fi
}

# Initialize dot-commander
init_dot_commander() {
    log_info "Initializing dot-commander..."
    
    # Create workspace directory
    mkdir -p "${DC_WORKSPACE_DIR}"
    mkdir -p "${DC_BIN_DIR}"
    
    # Add initialization block to shell init files
    add_init_block
    
    log_info "dot-commander initialized"
    log_info "Run \`dotc ---help\` for usage information"
}

# Show help message
show_help() {
    echo "Usage:"
    echo "  dotc ---init: Initialize the script's internal config"
    echo "  dotc ---scan <target_dir>: Initialize and scan the target directory for executables"
    echo "  dotc ---help: Show this help message"
    echo "  dotc <sub_command>: Execute a sub-command"
    echo ""
    
    if [ ! -f "$DC_COMMAND_INDEX" ]; then
        echo "No command index found. Run 'dotc ---scan <dir>' to create one."
        return 0
    fi
    
    check_yq
    
    echo "Available Sub Commands:"
    
    # Parse YAML and extract command names
    # Redirect stderr to avoid log messages appearing in output
    local commands
    commands=$(yq eval '.commands[].name' "$DC_COMMAND_INDEX" 2>/dev/null || echo "")
    
    if [ -z "$commands" ]; then
        echo "  (no commands found)"
        return 0
    fi
    
    # Filter out any lines that look like log messages
    while IFS= read -r cmd; do
        if [ -n "$cmd" ] && [[ ! "$cmd" =~ ^[0-9]{12}[[:space:]]+INFO: ]]; then
            echo "  - $cmd"
        fi
    done <<< "$commands"
}

# Execute subcommand
execute_subcommand() {
    local subcommand="$1"
    shift  # Remove subcommand from arguments
    
    local wrapper_script="${DC_BIN_DIR}/${subcommand}.sh"
    
    if [ ! -f "$wrapper_script" ]; then
        log_error "Subcommand not found: ${subcommand}"
        log_error "Run 'dotc ---help' to see available commands"
        exit 1
    fi
    
    # Execute the wrapper script with remaining arguments
    exec "$wrapper_script" "$@"
}

# Main function
main() {
    local init_flag=false
    local scan_dir=""
    local help_flag=false
    local subcommand=""
    local original_args=("$@")
    local args_array=("$@")
    local i=0
    
    # First pass: parse flags and find subcommand
    while [ $i -lt ${#args_array[@]} ]; do
        local arg="${args_array[$i]}"
        case "$arg" in
            ---init)
                init_flag=true
                ;;
            ---scan)
                if [ $((i + 1)) -ge ${#args_array[@]} ]; then
                    log_error "---scan requires a directory argument"
                    exit 1
                fi
                scan_dir="${args_array[$((i + 1))]}"
                i=$((i + 1))  # Skip the directory argument
                ;;
            ---help)
                help_flag=true
                ;;
            *)
                # This should be the subcommand (first non-flag argument)
                if [ -z "$subcommand" ] && [[ ! "$arg" =~ ^--- ]]; then
                    subcommand="$arg"
                fi
                ;;
        esac
        i=$((i + 1))
    done
    
    # Handle flags
    if [ "$help_flag" = true ]; then
        show_help
        exit 0
    fi
    
    # Handle ---scan: automatically initializes and scans
    if [ -n "$scan_dir" ]; then
        # Initialize (if not already done) and scan
        init_dot_commander
        scan_and_create_wrappers "$scan_dir"
        exit 0
    fi
    
    # Handle standalone ---init
    if [ "$init_flag" = true ]; then
        init_dot_commander
        exit 0
    fi
    
    # Handle subcommand execution
    if [ -n "$subcommand" ]; then
        # Reconstruct arguments without the subcommand and flags
        local remaining_args=()
        local found_subcommand=false
        local skip_next=false
        
        for ((j=0; j<${#original_args[@]}; j++)); do
            local arg="${original_args[$j]}"
            
            # Skip the next argument if we encountered ---scan
            if [ "$skip_next" = true ]; then
                skip_next=false
                continue
            fi
            
            # Skip flags
            case "$arg" in
                ---init|---help)
                    continue
                    ;;
                ---scan)
                    skip_next=true  # Skip the directory argument
                    continue
                    ;;
            esac
            
            # Skip the subcommand itself (only once)
            if [ "$found_subcommand" = false ] && [ "$arg" = "$subcommand" ]; then
                found_subcommand=true
                continue
            fi
            
            # Add all other arguments
            remaining_args+=("$arg")
        done
        
        # Safely pass remaining arguments (handle empty array case with set -u)
        # Check if array has elements before expanding to avoid unbound variable error
        if [ "${#remaining_args[*]}" -gt 0 ]; then
            execute_subcommand "$subcommand" "${remaining_args[@]}"
        else
            execute_subcommand "$subcommand"
        fi
        exit 0
    fi
    
    # No valid command provided
    log_error "No valid command provided. Run 'dotc ---help' for usage information."
    exit 1
}

# Run main function
main "$@"

